<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: v2.0</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">v2.0 </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Naudojimo instrukcija</h1>
<p >Paledus programą vartotojas gaus sąrašą įmanomų funkcijų:</p><ol type="1">
<li>Duomenu vedimas ranka (v0.1)</li>
<li>Duomenu skaitymas is failo(v0.2)</li>
<li>Failu generavimas(v0.3)</li>
<li>Spartos testas(v0.4)</li>
<li>Spartos testas su skirtingais algoritmais(v0.5)</li>
</ol>
<ul>
<li>Norima funkcija pasirenkama įvedant atitinkamą numerį</li>
<li>Vartotojui pateikiami pasirinkimai: (V/M) - čia "V" arba "v" - vidurkis, "M" arba "m" - mediana; (P/A) - čia "P" arba "p" - patys, "A" arba "a" - atsitiktinai; (T/N) - čia "T" arba "t" - taip, "N" arba "n" - ne.</li>
<li>Pasirinkus duomenis įvesti rankiniu būdu, galima rinktis, ar pažymius generuoti atsitiktinai, ar vesti ranka, bei ar galutinį balą išvesti pagal vidurkį, ar pagal medianą.</li>
<li>Pasirinkus generuoti failus, reikia įvesti norimą duomenų skaičių.</li>
<li>Kiekvienos funckijos pabaigoje galima rinktis, ar baigti darbą. Jei norite vykdyti dar vieną funkciją, rinkitės "N".</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
v0.1</h1>
<p >Šioje programoje vartotojas įrašo studentų duomenis: vardą, pavardę, pažymių skaičių, pačius pažymius ir egzamino rezultatą. Vartotojas taip pat gali pasirinkti pažymius generuoti atsitiktinai. Toliau vartotojui pateikiamas pasirinkimas, kaip skaičiuoti galutinį rezultatą - naudojant vidurkį ar medianą. Vartotojui pasirinkus, programa apskaičiuoja galutinį rezultatą ir išveda jį į ekraną su atitinkamų studentų vardais ir pavardėmis. Programa realizuota naudojant du skirtingus konteinerių tipus: vektorius ir dinaminius masyvus.</p>
<p >Pastaba: dinaminio masyvo kode yra klaida, jis iki galo neveikia.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
v0.2</h1>
<p >Toliau programą kuriame naudojant tik vektoriaus tipo konteinerį. Šioje versijoje v0.1 papildome galimybe studentų duomenis nuskaityti iš failo. Toliau atliekami veiksmai - studentų galutinio rezultato suskaičiavimas naudojant vidurkį arba medianą (priklausomai nuo vartotojo pasirinkimo). Gauti rezultatai tuomet yra išrašomi į naują failą.</p>
<p >Atliktas programos refactoring'as - funkcijų ir main failai iškelti į atskirus .cpp failus, o struktūra - į .h failą.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
v0.3</h1>
<p >Šioje versijoje papildome v0.2 versiją galimybe studentų duomenų failą generuoti atsitiktinai. Generuojami 1 000, 10 000, 100 000, 1 000 000, 10 000 000 įrašų failai, priklausomai nuo vartotojo pasirinkimo. Toliau sugeneruoti failai yra nuskaitomi, vartotojui leidžiama pasirinkti, kaip skaičiuoti galutinį rezultatą. Jį suskaičiavus, studentai yra išskirstomi į dvi grupes: moksliukai(galutinis yra &gt;=5) ir vargšiukai (galutinis yra &lt; 5). Galiausiai, šios dvi grupės yra įrašomos į du naujus failus.</p>
<p >Programa taip pat atlieka laiko matavimą failų generavimui, nuskaitymui, išskirstymui bei įrašymui į failus. Žemiau pateikti laiko matavimo rezultatai kiekvienam duomenų kiekiui.</p>
<p >1000 failų sugeneruoti užtruko 0.0273sek, nuskaityti - 0.0224sek, surūšiuoti - 0.005sek, įrašyti į du failus - 0.0182sek.</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/207101726-feeb1693-2af0-41e2-88fd-7d0c97b706f8.png" alt="image" class="inline"/></p>
<p >10000 failų sugeneruoti užtruko 0.276sek, nuskaityti - 0.193sek, surūšiuoti - 0.0469sek, įrašyti į du failus - 0.08sek.</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/207101777-5781bf33-6de5-4149-a64a-223d6dbd80c8.png" alt="image" class="inline"/></p>
<p >100000 failų sugeneruoti užtruko 2.716sek, nuskaityti - 2.061sek, surūšiuoti - 0.48sek, įrašyti į du failus - 0.723sek.</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/207101884-7775db2e-a491-4b0c-9d68-4106a9403f28.png" alt="image" class="inline"/></p>
<p >1000000 failų sugeneruoti užtruko 27sek, nuskaityti - 23sek, surūšiuoti - 4.723sek, įrašyti į du failus - 7.304sek.</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/207101971-37866f5c-3542-4c88-a942-d9328eb2b467.png" alt="image" class="inline"/></p>
<p >10000000 failų sugeneruoti užtruko apie 20min, nuskaityti - 6min, surūšiuoti - 1min19sek, įrašyti į du failus - 1min17sek.</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/207102078-feda91b9-9a34-464c-a4e6-9c7002cef8d5.png" alt="image" class="inline"/></p>
<p >Įdomus pastebėjimas: programos veikimo laikas generuojant 10000000 failų buvo net keturis kartus mažensis, kai kompiuteris buvo prijungtas prie krovimo laido - tada programa užtruko vos 5min.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
v0.4</h1>
<p >0.3 versiją papildome galimybe atlikti failų įrašymo spartos testą tarp skirtingų konteinerių tipų: std::list ir std::vector. Spartos testas matuoja failų nuskaitymo ir duomenų išskirstymo į dvi grupes pagal galutinį balą laiką.</p>
<p >Žemiau pateiktoje iškarpoje yra testavimo rezultatai. Juose matome, jog, nepriklausomai nuo duomenų kiekio, programa darbą atliko greičiau su std::list tipo struktūra.</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/207102862-7a929ce1-c764-4cca-bc73-28486569397d.png" alt="image" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md6"></a>
v1.0</h1>
<p >Visos aukščiau išvardintos funkcijos apjungiamos į vieną programą. Kad būtų paprasčiau skaityti kodą atliktas papildomas refactoring'as išskadant funkcijas pagal jų tipą. Taip pat vartotojo patogumo dėlei programa pakeista iš klausimų "Ar norite daryti ....", į meniu pasirinkimus.</p>
<p >Atliekamas programos spartos testas naudojant skirtingas studentų dalijimo į dvi kategorijas strategijas - kuriant tik vieną naują konteinerį n ir į jį sukeliant duomenis studentų, kurių galutinis balas mažesnis už 5.0, o kitus paliekant konteineryje stud, arba kuriant du naujus konteinerius.</p>
<p >Abiejoms strategijoms naudoti algoritmai:</p><ul>
<li>std::sort - duomenys vektoriuje išdėstomi didėjimo tvarka pagal galutinį balą;</li>
<li>std::find_if - randamas pirmas elementas vektoriuje, kurio galutinis balas lygus 5.0;</li>
<li>std::move - į naują vektorių sukeliami elementai iki to, kurio galutinis balas lygus 5.0. Antroje strategijoje elementai, esantys po rasto elemento taip pat sukeliami į naują konteinerį;</li>
<li>Pirmoje strategijoje naudotas std::erase - iš pirmojo konteinerio ištrinami elementai, perkelti į naują konteinerį.</li>
</ul>
<p ><img src="https://user-images.githubusercontent.com/112683136/207106011-a61e5be5-7675-40a9-9431-cf5953126e77.png" alt="image" class="inline"/></p>
<p >Iš rezultatų matome, kad programa veikia greičiausiai su vienu list tipo konteineriu, ir apskritai list konteineriai yra spartens, nei vector, nepriklausomai nuo jų kiekio.</p>
<p >Taip pat vykdytas programos spartos testas naudojant tik std::vector konteinerio tipą, tačiau jam taikant skirtingus algoritmus:</p><ul>
<li>Toks pat algoritmas, kaip atliekant spartos testą sukuriant tik vieną naują konteinerį;</li>
<li>Dalis duomenų sukeliami į naują konteinerį naudojant std::stable_partition ir std::copy algoritmus. Į naują vektorių sukelti duomenys iš senojo pašalinami naudojant std::erase algoritmą;</li>
<li>Toks pat algoritmas, kaip atliekant spartos testą sukuriant du naujus konteinerius;</li>
<li>Duomenys išskirstomi į du naujus vektorius naudojant std::partition_copy algoritmą.</li>
</ul>
<p ><img src="https://user-images.githubusercontent.com/112683136/207106643-ba833a48-724f-427c-96eb-22a89aa55114.png" alt="image" class="inline"/></p>
<p >Čia pastebime, jog tiek stable_partition ir copy, tiek partition_copy algoritmų pritaikymas yra efektyvesnis už algoritmus, naudotus pirmame spartos teste, kai duomenų kiekis yra 1000, 10000 arba 1000000. Kai turime 100000 arba 10000000 duomenų akivaizdžiai sparčiausias algoritmas yra partition_copy, o visi kiti algoritmai užtrunka maždaug tiek pat laiko.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
v1.1</h1>
<p >Šioje versijoje studento tipas pakeičiamas iš struktūros į klasę ir atitinkamai pritaikytos v1.0 funkcijos. Atliktas spartos testas lyginant greičius tarp programos, naudojančios struktūrą, ir programos, naudojančios klasę.</p>
<p >Struktūra:</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/208912118-f524c58a-ff18-41c1-b7a4-df92351a1730.png" alt="image" class="inline"/></p>
<p >Klasė:</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/208912162-6d484dd7-d6ba-4b8d-902e-7b98bcab1901.png" alt="image" class="inline"/></p>
<p >Iš rezultatų matome, kad programa veikia beveik tokiu pačiu greičiu naudojant tiek struktūrą, tiek klasę.</p>
<p >Toliau atlikti testai su kompiliatoriaus optimizavimo lygiais:</p>
<p >O1:</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/208912222-1adc4631-067c-4b2e-b4cc-769450389342.png" alt="image" class="inline"/></p>
<p >O2:</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/208912253-7dfc1199-111e-476f-a742-a1176e5d7c74.png" alt="image" class="inline"/></p>
<p >Ox:</p>
<p ><img src="https://user-images.githubusercontent.com/112683136/208912282-f7819f06-28f0-494e-be51-309ca99be4af.png" alt="image" class="inline"/></p>
<p >Iš rezultatų matome, kad programa užtrunka praktiškai tiek pat laiko, nepriklausomai nuo optimizacijos lygio.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
v1.2</h1>
<p >Programa papildyta pagal trijų taisyklę - pridėtas destruktorius, kopijavimo konstruktorius ir copy assignment operatorius.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
v1.5</h1>
<p >Studento klasė išskaidyta į dvi - bazinę abstrakčią klasę žmogus ir paveldėtą klasę studentas.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
v2.0</h1>
<p >Sukurta programos dokumentacija naudojant Doxygen.</p>
<p >Testavimo sistemos parametrai: CPU 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz 2.80 GHz; RAM 16GB; SSD. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
